{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data-Alchemy is a library made to handle Roblox datastores in a declarative fashion, similarly to libraries such as sqlAlchemy, being mainly inspired by sqlAlchemy. If you find anything missing from this documentation or that is incorrect, Open an issue on GitHub ! Info This documentation was made with the assumption you have some familiarity with Lua programming. If you're new to Lua, you should read some resources such as Programming in Lua by Roberto lerusalimschy and the documentation for Lua 5.0. Info This documentation was also made with the assumption you have an understanding of how Promises work. If you don't know how they work, you should read the documentation for the Promise implementation we use .","title":"Home"},{"location":"api-reference/","text":"Classes \u00b6 Model \u00b6 DataAlchemy . Model . new ( datastoreName , [ datastoreScope ]) -> Model A class that is the primary instance used in Data-Alchemy, it represents the structure that a datastore's contents should assume and enforces it. Model[index] = column \u00b6 Model [ index ] = Column Sets the specified index in the model to a Column class which is used to represent what should be in that index in the structure of a key. Model:GetColumn \u00b6 Model : GetColumn ( name ) -> Column | nil Returns the Column at the specified index if it exists. Model:GetColumnList \u00b6 Model : GetColumnList () -> Array < Column > Returns all the Column instances in the model with their indexes being identical to their indexes in the model. Model:NewKey \u00b6 Model : NewKey ( index ) -> Key Creates a new Key instance for this model with the specified index, which refers to the key it would represent in the datastore. Model:NewTransaction \u00b6 Model : NewTransaction () Creates a new Transaction instance for this datastore which can be used to perform multiple datastore interactions at once with the guarantee that it will only succeed if all the actions succeed. Model.Query \u00b6 A Query instance for this model that allows you to perform queries on the datastore to get specified keys or list keys based on specifications. Model.Session \u00b6 A Transaction instance for this model that will automatically flush the transaction as soon as the actions have been committed. Column \u00b6 DataAlchemy . Column . new ( type_ , [ default , [ nullable , [ onUpdate ]]]) -> Column A class that represents how an index in the key structure should be treated. Default is an optional argument that specifies the default value for this column, it can be either a value or a function which returns a value, if it is a function, the first argument provided to the function will be the key's index. Nullable is an optional argument that specifies whether or not this value can be nil and onUpdate is a function fired for this column whenever a key gets updated, it will be fired with the key's index as the first argument and the key's value as the second argument. Info The only functions this class has are intended for internal use only. Key \u00b6 A class that represents a key in the datastore. Warning This class is not intended to be created manually outside of internal functions that do so, anything that occurs as a result of creating one outside of an internal function will not be fixed. Key.UserIds \u00b6 An array of the UserIds associated with this key. Key.Version \u00b6 The version of this key. Key.CreatedTime \u00b6 The time this key was created at. Key.UpdatedTime \u00b6 The time this key was last updated. Key:GetMetadata \u00b6 Key : GetMetadata () -> Dictionary < any > Gets the metadata associated with this key. Query \u00b6 Model . Query -> Query An object that can perform queries on a Model's datastore. Query:FilterByKey \u00b6 Query : FilterByKey ( name , [ version ]) -> Key Queries the datastore for a specified key, with an optional version of the key to query for. Query:FilterByPrefix \u00b6 Query : FilterByPrefix ([ prefix , [ pageSize ]]) -> QueryResult Queries the datastore for keys that start with the specified prefix or blank if not specified and returns a QueryResult instance that can be used to go through the results. Query:FilterByKeyVersion \u00b6 Query : FilterByKeyVersion ( key , [ sortDirection , [ minDate , [ maxDate , [ pageSize ]]]]) -> QueryResult Queries the datastore for versions of the specified key, within the specified minimum and maximum date ranges or no date range if not specified and a sort direction if specified. Returns a QueryResult instance. QueryResult \u00b6 An instance that is returned by some Query methods to search through the results of the query. QueryResult:GetCurrent \u00b6 QueryResult : GetCurrent () -> Promise Returns a promise which returns an array of QueryKey instances that represent keys in the query upon success. QueryResult:GetNext \u00b6 QueryResult : GetNext () -> Promise Attempts to advance to the next page of the query and then returns the results of QueryResult:GetCurrent() QueryKey \u00b6 An instance that provides information about a key returned from a QueryResult QueryKey.Name \u00b6 The name of the key in the datastore. QueryKey.CreatedTime \u00b6 The time at which this key was created. QueryKey.IsDeleted \u00b6 Whether or not this key was removed. QueryKey.Version \u00b6 The version of this key. Caution Name is the only property filled in if this QueryKey was generated from a QueryResult resulting from Query:FilterByPrefix Transaction \u00b6 An instance that handles multiple atomic interactions with a datastore, guaranteeing that all interactions are successful or none go through. Transaction:Set \u00b6 Transaction : Set ( key , [ setoptions ]) Creates an action in this transaction for a key in the datastore to be set using SetAsync Key must be a Key instance. Transaction:Update \u00b6 Transaction : Update ( index , updateFunc ) Creates an action in this transaction for UpdateAsync to be used on the specified key index in the datastore. index must be a string Transaction:Remove \u00b6 Transaction : Remove ( index , [ version ]) Creates an action in this transaction for a key to be removed from the datastore using RemoveAsync , or RemoveVersionAsync if a version is specified. index must be a string Transaction:Commit \u00b6 Transaction : Commit () -> Promise Commits all changes to the datastore, and if successful, the Promise will return an Array containing Dictionaries with the results of each action, in the order they were added to the transaction. The contents of the dictionary depend on the type of action: SET = { Version ; } REMOVE = { Values ; KeyInfo ; } UPDATE = { Values ; KeyInfo ; } Transaction:Flush \u00b6 Transaction : Flush () Clears the transaction of all actions that had been assigned within it.","title":"API Reference"},{"location":"api-reference/#classes","text":"","title":"Classes"},{"location":"api-reference/#model","text":"DataAlchemy . Model . new ( datastoreName , [ datastoreScope ]) -> Model A class that is the primary instance used in Data-Alchemy, it represents the structure that a datastore's contents should assume and enforces it.","title":"Model"},{"location":"api-reference/#modelindex-column","text":"Model [ index ] = Column Sets the specified index in the model to a Column class which is used to represent what should be in that index in the structure of a key.","title":"Model[index] = column"},{"location":"api-reference/#modelgetcolumn","text":"Model : GetColumn ( name ) -> Column | nil Returns the Column at the specified index if it exists.","title":"Model:GetColumn"},{"location":"api-reference/#modelgetcolumnlist","text":"Model : GetColumnList () -> Array < Column > Returns all the Column instances in the model with their indexes being identical to their indexes in the model.","title":"Model:GetColumnList"},{"location":"api-reference/#modelnewkey","text":"Model : NewKey ( index ) -> Key Creates a new Key instance for this model with the specified index, which refers to the key it would represent in the datastore.","title":"Model:NewKey"},{"location":"api-reference/#modelnewtransaction","text":"Model : NewTransaction () Creates a new Transaction instance for this datastore which can be used to perform multiple datastore interactions at once with the guarantee that it will only succeed if all the actions succeed.","title":"Model:NewTransaction"},{"location":"api-reference/#modelquery","text":"A Query instance for this model that allows you to perform queries on the datastore to get specified keys or list keys based on specifications.","title":"Model.Query"},{"location":"api-reference/#modelsession","text":"A Transaction instance for this model that will automatically flush the transaction as soon as the actions have been committed.","title":"Model.Session"},{"location":"api-reference/#column","text":"DataAlchemy . Column . new ( type_ , [ default , [ nullable , [ onUpdate ]]]) -> Column A class that represents how an index in the key structure should be treated. Default is an optional argument that specifies the default value for this column, it can be either a value or a function which returns a value, if it is a function, the first argument provided to the function will be the key's index. Nullable is an optional argument that specifies whether or not this value can be nil and onUpdate is a function fired for this column whenever a key gets updated, it will be fired with the key's index as the first argument and the key's value as the second argument. Info The only functions this class has are intended for internal use only.","title":"Column"},{"location":"api-reference/#key","text":"A class that represents a key in the datastore. Warning This class is not intended to be created manually outside of internal functions that do so, anything that occurs as a result of creating one outside of an internal function will not be fixed.","title":"Key"},{"location":"api-reference/#keyuserids","text":"An array of the UserIds associated with this key.","title":"Key.UserIds"},{"location":"api-reference/#keyversion","text":"The version of this key.","title":"Key.Version"},{"location":"api-reference/#keycreatedtime","text":"The time this key was created at.","title":"Key.CreatedTime"},{"location":"api-reference/#keyupdatedtime","text":"The time this key was last updated.","title":"Key.UpdatedTime"},{"location":"api-reference/#keygetmetadata","text":"Key : GetMetadata () -> Dictionary < any > Gets the metadata associated with this key.","title":"Key:GetMetadata"},{"location":"api-reference/#query","text":"Model . Query -> Query An object that can perform queries on a Model's datastore.","title":"Query"},{"location":"api-reference/#queryfilterbykey","text":"Query : FilterByKey ( name , [ version ]) -> Key Queries the datastore for a specified key, with an optional version of the key to query for.","title":"Query:FilterByKey"},{"location":"api-reference/#queryfilterbyprefix","text":"Query : FilterByPrefix ([ prefix , [ pageSize ]]) -> QueryResult Queries the datastore for keys that start with the specified prefix or blank if not specified and returns a QueryResult instance that can be used to go through the results.","title":"Query:FilterByPrefix"},{"location":"api-reference/#queryfilterbykeyversion","text":"Query : FilterByKeyVersion ( key , [ sortDirection , [ minDate , [ maxDate , [ pageSize ]]]]) -> QueryResult Queries the datastore for versions of the specified key, within the specified minimum and maximum date ranges or no date range if not specified and a sort direction if specified. Returns a QueryResult instance.","title":"Query:FilterByKeyVersion"},{"location":"api-reference/#queryresult","text":"An instance that is returned by some Query methods to search through the results of the query.","title":"QueryResult"},{"location":"api-reference/#queryresultgetcurrent","text":"QueryResult : GetCurrent () -> Promise Returns a promise which returns an array of QueryKey instances that represent keys in the query upon success.","title":"QueryResult:GetCurrent"},{"location":"api-reference/#queryresultgetnext","text":"QueryResult : GetNext () -> Promise Attempts to advance to the next page of the query and then returns the results of QueryResult:GetCurrent()","title":"QueryResult:GetNext"},{"location":"api-reference/#querykey","text":"An instance that provides information about a key returned from a QueryResult","title":"QueryKey"},{"location":"api-reference/#querykeyname","text":"The name of the key in the datastore.","title":"QueryKey.Name"},{"location":"api-reference/#querykeycreatedtime","text":"The time at which this key was created.","title":"QueryKey.CreatedTime"},{"location":"api-reference/#querykeyisdeleted","text":"Whether or not this key was removed.","title":"QueryKey.IsDeleted"},{"location":"api-reference/#querykeyversion","text":"The version of this key. Caution Name is the only property filled in if this QueryKey was generated from a QueryResult resulting from Query:FilterByPrefix","title":"QueryKey.Version"},{"location":"api-reference/#transaction","text":"An instance that handles multiple atomic interactions with a datastore, guaranteeing that all interactions are successful or none go through.","title":"Transaction"},{"location":"api-reference/#transactionset","text":"Transaction : Set ( key , [ setoptions ]) Creates an action in this transaction for a key in the datastore to be set using SetAsync Key must be a Key instance.","title":"Transaction:Set"},{"location":"api-reference/#transactionupdate","text":"Transaction : Update ( index , updateFunc ) Creates an action in this transaction for UpdateAsync to be used on the specified key index in the datastore. index must be a string","title":"Transaction:Update"},{"location":"api-reference/#transactionremove","text":"Transaction : Remove ( index , [ version ]) Creates an action in this transaction for a key to be removed from the datastore using RemoveAsync , or RemoveVersionAsync if a version is specified. index must be a string","title":"Transaction:Remove"},{"location":"api-reference/#transactioncommit","text":"Transaction : Commit () -> Promise Commits all changes to the datastore, and if successful, the Promise will return an Array containing Dictionaries with the results of each action, in the order they were added to the transaction. The contents of the dictionary depend on the type of action: SET = { Version ; } REMOVE = { Values ; KeyInfo ; } UPDATE = { Values ; KeyInfo ; }","title":"Transaction:Commit"},{"location":"api-reference/#transactionflush","text":"Transaction : Flush () Clears the transaction of all actions that had been assigned within it.","title":"Transaction:Flush"},{"location":"guide/datatypes/","text":"In Data Alchemy, DataTypes are a set of custom classes that are used by the library to validate, serialize, and deserialize keys in a table. They tell the library how this key should be confirmed to be valid, how this key should be converted in order to be saved to the datastore successfully, and how this key should be converted back from the datastore in order for you to interact with it painlessly. In Data Alchemy, there currently exist 9 DataTypes, which will be listed below. String \u00b6 DataAlchemy . String ( MaxLength ) -> String The String DataType is a datatype specifying a string and uses a constructor that allows you to specify the maximum length of the string, if no max length is defined it defaults to infinity. Float \u00b6 DataAlchemy . Float -> Float DataAlchemy . Float ( options ) -> Float The Float DataType is a datatype specifying a number that may contain decimal places. It will only accept a number. When this is called like a constructor function, it should be provided a table of options as its first argument, these options can be: { Negative = boolean ; Positive = boolean ; Min = number ; Max = number ; } Negative & Positive will enforce a rule where the number provided must be negative or positive depending on which you set to true, you shouldn't enable both at once. Min and Max will enforce a rule where the number provided must be within the specified range (they can be specified on their own, without the presence of the other). Integer \u00b6 DataAlchemy . Integer -> Integer DatAlchemy . Integer ( options ) -> Integer The Integer DataType is a datatype specifying a number that can only be a full number, it will only accept a number and will automatically round the number down to a full number. Integer has an identical constructor function to Float Boolean \u00b6 DataAlchemy . Boolean -> Boolean The Boolean DataType is a datatype specifying a true or false value, it will only accept a boolean. Dictionary \u00b6 DataAlchemy . Dictionary ( structure ) -> Dictionary The Dictionary DataType is a datatype specifying a table that may only accept the keys and their specified DataTypes inside the structure argument provided when firing the constructor for the dictionary datatype. Its key names must be strings. The format of the structure argument is: { KEYNAME = DATATYPE ; } Array \u00b6 DataAlchemy . Array ( datatype ) -> Array The Array DataType is a datatype specifying a table that may only accept numbers as keys. The datatype will reject a value if it has a gap between two keys. datatype specifies what DataType should be used to validate all the keys in the array. Enum \u00b6 DataAlchemy . Enum ( enum ) -> Enum The Enum DataType is a datatype specifying a Roblox enum to use for the key, the enum argument will only accept an Enum and is used to construct a Enum datatype that will validate and properly serialize/deserialize a value used for this key. Providing just the Enum container itself will make the Enum datatype only accept an Enum specifier (Meaning you should provide this key a value like Enum.Material instead of Enum.Material.Air for example). DateTime \u00b6 DataAlchemy . DateTime -> DateTime The DateTime DataType is a datatype specifying a Roblox DateTime datatype, it will automatically handle serialization of the datatype to the datastore and deserialization when getting the key in order to make using them as painless as possible for the developer. Roblox DataTypes \u00b6 The following Roblox DataTypes have custom DataTypes specified in Data-Alchemy: Axes BrickColor CFrame Color3 ColorSequence Faces NumberRange NumberSequence Rect Region3 Region3int16 UDim UDim2 Vector2 Vector2int16 Vector3 Vector3int16 Union \u00b6 DataAlchemy . Union ( datatype , ...) -> Union The Union DataType is a datatype specifying a column that accepts any of the datatypes specified within the constructor. Example construction of a Union datatype could look like: DataAlchemy . Union ( DataAlchemy . String , DataAlchemy . Number , DataAlchemy . Boolean )","title":"DataTypes"},{"location":"guide/datatypes/#string","text":"DataAlchemy . String ( MaxLength ) -> String The String DataType is a datatype specifying a string and uses a constructor that allows you to specify the maximum length of the string, if no max length is defined it defaults to infinity.","title":"String"},{"location":"guide/datatypes/#float","text":"DataAlchemy . Float -> Float DataAlchemy . Float ( options ) -> Float The Float DataType is a datatype specifying a number that may contain decimal places. It will only accept a number. When this is called like a constructor function, it should be provided a table of options as its first argument, these options can be: { Negative = boolean ; Positive = boolean ; Min = number ; Max = number ; } Negative & Positive will enforce a rule where the number provided must be negative or positive depending on which you set to true, you shouldn't enable both at once. Min and Max will enforce a rule where the number provided must be within the specified range (they can be specified on their own, without the presence of the other).","title":"Float"},{"location":"guide/datatypes/#integer","text":"DataAlchemy . Integer -> Integer DatAlchemy . Integer ( options ) -> Integer The Integer DataType is a datatype specifying a number that can only be a full number, it will only accept a number and will automatically round the number down to a full number. Integer has an identical constructor function to Float","title":"Integer"},{"location":"guide/datatypes/#boolean","text":"DataAlchemy . Boolean -> Boolean The Boolean DataType is a datatype specifying a true or false value, it will only accept a boolean.","title":"Boolean"},{"location":"guide/datatypes/#dictionary","text":"DataAlchemy . Dictionary ( structure ) -> Dictionary The Dictionary DataType is a datatype specifying a table that may only accept the keys and their specified DataTypes inside the structure argument provided when firing the constructor for the dictionary datatype. Its key names must be strings. The format of the structure argument is: { KEYNAME = DATATYPE ; }","title":"Dictionary"},{"location":"guide/datatypes/#array","text":"DataAlchemy . Array ( datatype ) -> Array The Array DataType is a datatype specifying a table that may only accept numbers as keys. The datatype will reject a value if it has a gap between two keys. datatype specifies what DataType should be used to validate all the keys in the array.","title":"Array"},{"location":"guide/datatypes/#enum","text":"DataAlchemy . Enum ( enum ) -> Enum The Enum DataType is a datatype specifying a Roblox enum to use for the key, the enum argument will only accept an Enum and is used to construct a Enum datatype that will validate and properly serialize/deserialize a value used for this key. Providing just the Enum container itself will make the Enum datatype only accept an Enum specifier (Meaning you should provide this key a value like Enum.Material instead of Enum.Material.Air for example).","title":"Enum"},{"location":"guide/datatypes/#datetime","text":"DataAlchemy . DateTime -> DateTime The DateTime DataType is a datatype specifying a Roblox DateTime datatype, it will automatically handle serialization of the datatype to the datastore and deserialization when getting the key in order to make using them as painless as possible for the developer.","title":"DateTime"},{"location":"guide/datatypes/#roblox-datatypes","text":"The following Roblox DataTypes have custom DataTypes specified in Data-Alchemy: Axes BrickColor CFrame Color3 ColorSequence Faces NumberRange NumberSequence Rect Region3 Region3int16 UDim UDim2 Vector2 Vector2int16 Vector3 Vector3int16","title":"Roblox DataTypes"},{"location":"guide/datatypes/#union","text":"DataAlchemy . Union ( datatype , ...) -> Union The Union DataType is a datatype specifying a column that accepts any of the datatypes specified within the constructor. Example construction of a Union datatype could look like: DataAlchemy . Union ( DataAlchemy . String , DataAlchemy . Number , DataAlchemy . Boolean )","title":"Union"},{"location":"guide/installation/","text":"Data-Alchemy has two supported ways to get started with. Method 1: Model File (via Roblox Studio) \u00b6 Download the rbxm model file attached with the latest release from the Github releases page Import the model file into Studio into a location like ReplicatedStorage Method 2: Filesystem \u00b6 Copy the src directory into your codebase Use a plugin like Rojo to sync the files into your place","title":"Installation"},{"location":"guide/installation/#method-1-model-file-via-roblox-studio","text":"Download the rbxm model file attached with the latest release from the Github releases page Import the model file into Studio into a location like ReplicatedStorage","title":"Method 1: Model File (via Roblox Studio)"},{"location":"guide/installation/#method-2-filesystem","text":"Copy the src directory into your codebase Use a plugin like Rojo to sync the files into your place","title":"Method 2: Filesystem"},{"location":"guide/model/","text":"In Data-Alchemy, a Model is a class that allows you to define Column instances that define how the data in a Roblox Datastore should be treated and handled. A model can be defined as such: local DataAlchemy = require ( game . ReplicatedStorage . DataAlchemy ) local OurModel = DataAlchemy . Model . new ( \"DataStoreName\" ) Adding onto this, we can next define the columns of our model by setting indexes in our Model class to newly created Column objects like so: local DataAlchemy = require ( game . ReplicatedStorage . DataAlchemy ) local Column = DataAlchemy . Column local String = DataAlchemy . String local Number = DataAlchemy . Number local OurModel = DataAlchemy . Model . new ( \"DataStoreName\" ) OurModel . Name = Column . new ( String ( 30 ), \"\" ) OurModel . Bio = Column . new ( String ( 300 ), \"\" ) OurModel . Avatar = Column . new ( Number , 0 ) In this example, we have created a model where Name is a string that can have a max of 30 characters and a default of a blank string, Bio is a string with a max of 300 characters and a default of a blank string, and Avatar is a number that defaults to zero. Info For more information on DataTypes, checkout the DataTypes guide!","title":"Models"},{"location":"guide/transactions/","text":"In Data Alchemy, We make use of something known as a Transaction , which allows us to perform either one datastore operation or multiple at once, with the guarantee that it will only apply all of the changes if they all succeed. Info Curious and want to learn more about how a database transaction works? Check out this wikipedia page on the subject! Creating a Transaction \u00b6 In order to create a transaction, we must call NewTransaction on our Model instance like so: local transaction = OurModel : NewTransaction () After we have created our Transaction , we can then start adding actions to the transaction that will be performed once we're done. There are only 3 actions that a Transaction can perform, and these are: Set, Update, and Remove. Adding Actions to a Transaction \u00b6 In our Transaction class we have 3 functions for adding different types of actions to our transaction, which will be detailed here. Set \u00b6 The Set method of a transaction will add an action to perform a SetAsync operation, the key argument should be a Key instance created using Model:NewKey(index) like so: local transaction = OurModel : NewTransaction () local key = OurModel : NewKey ( \"SomePlayersUserId\" ) key . Avatar = 123456789 transaction : Set ( key ) Update \u00b6 The Update method of a transaction will add an action to perform an UpdateAsync operation, the index argument must be a string representing the key you wish to update and the updateFunc argument must be a function that, given the key's current data and keyinfo, returns updated data and keyinfo like so: local transaction = OurModel : NewTransaction () local function updateKey ( oldData , oldKeyInfo ) oldData . Name = \"Kamijou Touma\" return oldData , oldKeyInfo end transaction : Update ( \"SomePlayersUserId\" , updateKey ) Remove \u00b6 The Remove method of a transaction will add an action to perform a RemoveAsync operation, the index argument must be a string representing the key you wish to remove and has an optional version argument for specifying which version of the key to remove, if not specified it will remove the entire key, it can be used like so: local transaction = OurModel : NewTransaction () transaction : Remove ( \"SomePlayersUserId\" ) Committing a Transaction \u00b6 Once you've specified all the actions you wish to commit to the datastore for your transaction, you must then called the Commit method of the transaction like so: local transaction = OurModel : NewTransaction () local function updateKey ( oldData , oldKeyInfo ) oldData . Name = \"Kamijou Touma\" return oldData , oldKeyInfo end transaction : Update ( \"SomePlayersUserId\" , updateKey ) transaction : Commit () : andThen ( function ( results ) transaction : Flush () print ( \"Transaction was a success! Results:\" , results ) end ) It should also be noted that the function will return the results of each action, in the order in which the actions were added to the transaction. Once you're done with the transaction, you should call the Flush method of the transaction if you wish to reuse that instance for more transactions. Info Don't feel like creating a Transaction instance but know for certain that nothing will be trying to perform actions on the datastore at the same time? You can use the transaction in the model called Session ( OurModel.Session ) to add actions and then when committing them, it will immediately be flushed automatically once successful. Info For more information on the results of committing a Transaction , checkout the API Reference for what the results of an action may look like. Caution When committing a Transaction, one GetAsync call (if not performing an Update operation), two SetAsync calls, and one Set/Update/RemoveAsync call are used per key due to the system making sure that a transaction failing due to a crash is still reverted","title":"Transactions"},{"location":"guide/transactions/#creating-a-transaction","text":"In order to create a transaction, we must call NewTransaction on our Model instance like so: local transaction = OurModel : NewTransaction () After we have created our Transaction , we can then start adding actions to the transaction that will be performed once we're done. There are only 3 actions that a Transaction can perform, and these are: Set, Update, and Remove.","title":"Creating a Transaction"},{"location":"guide/transactions/#adding-actions-to-a-transaction","text":"In our Transaction class we have 3 functions for adding different types of actions to our transaction, which will be detailed here.","title":"Adding Actions to a Transaction"},{"location":"guide/transactions/#set","text":"The Set method of a transaction will add an action to perform a SetAsync operation, the key argument should be a Key instance created using Model:NewKey(index) like so: local transaction = OurModel : NewTransaction () local key = OurModel : NewKey ( \"SomePlayersUserId\" ) key . Avatar = 123456789 transaction : Set ( key )","title":"Set"},{"location":"guide/transactions/#update","text":"The Update method of a transaction will add an action to perform an UpdateAsync operation, the index argument must be a string representing the key you wish to update and the updateFunc argument must be a function that, given the key's current data and keyinfo, returns updated data and keyinfo like so: local transaction = OurModel : NewTransaction () local function updateKey ( oldData , oldKeyInfo ) oldData . Name = \"Kamijou Touma\" return oldData , oldKeyInfo end transaction : Update ( \"SomePlayersUserId\" , updateKey )","title":"Update"},{"location":"guide/transactions/#remove","text":"The Remove method of a transaction will add an action to perform a RemoveAsync operation, the index argument must be a string representing the key you wish to remove and has an optional version argument for specifying which version of the key to remove, if not specified it will remove the entire key, it can be used like so: local transaction = OurModel : NewTransaction () transaction : Remove ( \"SomePlayersUserId\" )","title":"Remove"},{"location":"guide/transactions/#committing-a-transaction","text":"Once you've specified all the actions you wish to commit to the datastore for your transaction, you must then called the Commit method of the transaction like so: local transaction = OurModel : NewTransaction () local function updateKey ( oldData , oldKeyInfo ) oldData . Name = \"Kamijou Touma\" return oldData , oldKeyInfo end transaction : Update ( \"SomePlayersUserId\" , updateKey ) transaction : Commit () : andThen ( function ( results ) transaction : Flush () print ( \"Transaction was a success! Results:\" , results ) end ) It should also be noted that the function will return the results of each action, in the order in which the actions were added to the transaction. Once you're done with the transaction, you should call the Flush method of the transaction if you wish to reuse that instance for more transactions. Info Don't feel like creating a Transaction instance but know for certain that nothing will be trying to perform actions on the datastore at the same time? You can use the transaction in the model called Session ( OurModel.Session ) to add actions and then when committing them, it will immediately be flushed automatically once successful. Info For more information on the results of committing a Transaction , checkout the API Reference for what the results of an action may look like. Caution When committing a Transaction, one GetAsync call (if not performing an Update operation), two SetAsync calls, and one Set/Update/RemoveAsync call are used per key due to the system making sure that a transaction failing due to a crash is still reverted","title":"Committing a Transaction"}]}